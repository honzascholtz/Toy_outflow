#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Sep  1 22:53:25 2021

@author: jansen
"""

#importing modules
import numpy as np
import matplotlib.pyplot as plt; plt.ioff()

from astropy.io import fits as pyfits
from astropy import wcs
from astropy.table import Table, join, vstack
from matplotlib.backends.backend_pdf import PdfPages
import pickle
from scipy.optimize import curve_fit


from scipy.misc import imresize
from scipy.ndimage.interpolation import rotate

from tqdm import tqdm
from datetime import date


from astropy.convolution import Gaussian2DKernel
from scipy.signal import convolve as scipy_convolve
from astropy.convolution import convolve

from spectral_cube import SpectralCube
import astropy.units as u
nan= float('nan')

pi= np.pi
e= np.e

from mpl_toolkits.mplot3d import Axes3D

def gaussian(x, mu, sig):
    return np.exp(-np.power(x - mu, 2.) / (2 * np.power(sig, 2.)))


def create_circular_mask(h, w, center=None, radius=None):

    if center is None: # use the middle of the image
        center = [int(w/2), int(h/2)]
    if radius is None: # use the smallest distance between the center and image walls
        radius = min(center[0], center[1], w-center[0], h-center[1])

    Y, X = np.ogrid[:h, :w]
    dist_from_center = np.sqrt((X - center[0])**2 + (Y-center[1])**2)

    mask = dist_from_center <= radius
    return mask

def overide_axes_labels(fig,ax,lims,showx=1,showy=1,labelx=1,labely=1,color='k',fewer_x=0,pruney=0,prunex=0,tick_color='k', tickin=0, labelsize=12, white=0):
    #over rides axis labels generated by wcsaxes in order to put relative coordinates in 
    
    #fig is the figure being plotted 
    #ax = axis to plot on 
    #lims is what you want on the axis (xmin,xmax,ymin,ymax) OR (img_wcs,im_hdr)
    #labelx / label y = bool, true if want tick and axis labels on the x / y axis
            
    #plt.ion()
    
    if len(lims)==2:
        img_wcs=lims[0]
        hdr=lims[1]
        o=np.array(img_wcs.all_pix2world(1,1,1))
        o=SkyCoord(o[0],o[1], unit="deg")
        p1=np.array(img_wcs.all_pix2world(hdr['NAXIS1'],1,1))
        p1=SkyCoord(p1[0],p1[1], unit="deg")
        p2=np.array(img_wcs.all_pix2world(1,hdr['NAXIS2'],1))
        p2=SkyCoord(p2[0],p2[1], unit="deg")
        
        arcsec_size= np.array([o.separation(p2).arcsec,o.separation(p1).arcsec,])/2.

        lims=[-arcsec_size[1],arcsec_size[1],-arcsec_size[0],arcsec_size[0]]
       
    lon = ax.coords[0]
    lat = ax.coords[1]
    
    lon.set_ticks_visible(False)
    lon.set_ticklabel_visible(False)
    lat.set_ticks_visible(False)
    lat.set_ticklabel_visible(False)    
    
    if showx or showy:        
        #plt.draw()
        #plt.pause(0.000000001)
        newax = fig.add_axes(ax.get_position(), frameon=False)  
    
        plt.xlim(lims[0],lims[1])
        plt.ylim(lims[2],lims[3])
    
        newax.xaxis.label.set_color(color)
        newax.tick_params(axis='x', colors=color)
        newax.tick_params(axis='x', color=tick_color)
    

        newax.yaxis.label.set_color(color)
        newax.tick_params(axis='y', colors=color)
        newax.tick_params(axis='y', color=tick_color)
          
        if not showx: gca().axes.xaxis.set_ticklabels([])
        if not showy: gca().axes.axes.yaxis.set_ticklabels([])
    
        if labely:    plt.ylabel('arcsec', fontsize=labelsize) 
        if labelx:    plt.xlabel('arcsec', fontsize=labelsize)
    
    
        if fewer_x: newax.set_xticks(newax.get_xticks()[::2])
    
        #newax.yaxis.set_major_locator(MaxNLocator(prune='both'))
        #newax.xaxis.set_major_locator(MaxNLocator(prune='both'))
        if pruney: newax.set_yticks(newax.get_yticks()[1:-1])
        if prunex: newax.set_xticks(newax.get_xticks()[1:-1])  
    
    if tickin==1:
        newax.tick_params(axis='y', direction='in', color='white')
        newax.tick_params(axis='x', direction='in', color='white')
    
    if tickin==2:
        newax.tick_params(axis='y', direction='in', color='black')
        newax.tick_params(axis='x', direction='in', color='black')
    
    if white==1:
        from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                               AutoMinorLocator)
        newax.xaxis.label.set_color('white')
        newax.yaxis.label.set_color('white')
        
        #plt.ylabel('arcsec', fontsize=labelsize, color='w') 
        #plt.xlabel('arcsec', fontsize=labelsize, color='w')
        
        plt.setp(newax.get_yticklabels(), color="white")
        plt.setp(newax.get_xticklabels(), color="white")
        
        #newax.xaxis.set_major_locator(MultipleLocator(4))
        #newax.yaxis.set_major_locator(MultipleLocator(4))
        
        #newax.xaxis.set_minor_locator(MultipleLocator(3))
        #newax.yaxis.set_minor_locator(MultipleLocator(3))
    

class Outflow:
    """ A class to organize the modelling of the outflow. """

    # to welcome you to the game and initialise the instance
    def __init__(self, v_launch=300, dispersion=400, opening_angle=40, arcsecond_per_pix=0.03125,outflow_r = 0.56, cube_size=2., npixel=64,inclination=45, PA=-45 , vels=np.linspace(-1200,1200,60 ), flux=10 , saving_fits = "n", mypath= '/Users/jansen/Downloads/test') :
        self.v_launch = v_launch
        self.dispersion = dispersion
        self.opn_agl = opening_angle
        self.inclination = inclination
        self.PA = PA
        
        self.arcsecond_per_pix = arcsecond_per_pix
        self.npixel = npixel
        self.outflow_r = outflow_r
        self.cube_size = cube_size
        self.cube_size_pix = int(cube_size/self.arcsecond_per_pix)
        
        self.bmaj = 0.4
        self.bmin = 0.4
        self.kernel_rotation = 0.2
        
        self.vels = vels
        self.frq0 = 0
        self.flux = flux
        
        self.save_fits = saving_fits
        self.mypath= mypath
        
        if outflow_r> cube_size:
            print('Outflow is bigger than the cube')
            raise

        print("---------------------------------------------------")
        print("---------------------------------------------------")
        print("Lets simulate some outflows!")
        print("There is a number of parameters you need to set and a number of plots that will appear for your convinience. ")
        print("Let's get started!")
        print("---------------------------------------------------")
        print(self.cube_size_pix)
    
        

    # printing the constants set for the disk
    def print_info(self):
        """ This function prints the values of the outflows. """
        print("---------------------------------------------------")
        print("---------------------------------------------------")
        print("The galaxy parameters are set as follows: ")
        print("The radius of the outflow in [parsec]: ", self.outflow_r)
        #print("Arcseconds per pixel: ", self.delt)
        print("Beam FWHM in x-direction [arcsec]: ", self.bmaj)
        print("Beam FWHM in y-direction [arcsec]: ", self.bmin)
        print("Rotation of beam in [degrees]: ", round(np.rad2deg(self.kernel_rotation)))
        #print("Would you like to save the maps and the spectral cube as fits files? [y/n]: ", A_save_fits)
        print("---------------------------------------------------")

    
    def create_model_grid(self):
        print('creating the particle grids to store data')
        Flux = np.zeros((self.npixel,self.npixel,self.npixel))
        Vel = np.zeros((self.npixel,self.npixel,self.npixel))

        for x in np.linspace(self.npixel/2, int(self.npixel-self.npixel/8), int(self.npixel-self.npixel/8)-self.npixel/2+1 , dtype=int):
                
            radius = np.tan((self.opn_agl/2)*np.pi/180)*(x-self.npixel/2+self.npixel/7)
            mask = create_circular_mask(self.npixel, self.npixel, center=None, radius=radius)    
            mask = np.array(mask, dtype=int)   
            Flux[x,:,:] = mask
            Vel[x,:,:] = self.v_launch
            
        for x in np.linspace( int(self.npixel/6), self.npixel/2-1, self.npixel/2-1-int(self.npixel/6)+1  , dtype=int):        
            radius = np.tan((self.opn_agl/2)*np.pi/180)*(-x+self.npixel/2+self.npixel/7)
            mask = create_circular_mask(self.npixel, self.npixel, center=None, radius=radius)    
            mask = np.array(mask, dtype=int)
            Flux[x,:,:] = mask
            Vel[x,:,:] = -self.v_launch
            
        return Flux, Vel
    
    
    def rotation(self, Flux, Vel):
        print ('Rotating the outflow around')
        
        Flux_rot = rotate(Flux, self.inclination, axes=(1,0), reshape=False)
        Flux_rot = rotate(Flux_rot, self.PA, axes=(2,0), reshape=False)
        
        Vel_rot = rotate(Vel, self.inclination, axes=(1,0), reshape=False)
        Vel_rot = rotate(Vel_rot, self.PA, axes=(2,0), reshape=False)
        Vel_rot = Vel_rot*np.sin(self.inclination*np.pi/180)
        
        return Flux_rot, Vel_rot
    
    def Plotting_rot(self, Flux, Flux_rot):
        print ('Plotting the outflow')
        f,axes = plt.subplots(1,2, figsize=(12,9))
        Map = Flux.sum(axis=(1))
        axes[0].imshow(Map, origin='low')
        axes[0].set_title('Cones')
        
        Map = Flux_rot.sum(axis=(1))
        axes[1].imshow(Map, origin='low')
        axes[1].set_title('Rotate 45 degreees towards us')
        
    
    
    def Spectral_matrix(self, Flux_rot, Vel_rot):
        print('Creating an unconvolved cube')
        D4_look = np.zeros((len(self.vels), self.npixel,self.npixel,self.npixel))

        for i in tqdm(range(self.npixel)):
            for j in range(self.npixel):
                for h in range(self.npixel):
                    
                    cent = self.frq0+Vel_rot[i,j,h]
                    width = self.dispersion/2.36
                    
                    D4_look[:,i,j,h] = Flux_rot[i,j,h,]* (gaussian(self.vels, cent,width))
        
        Cube_deconvolved = D4_look.sum(axis=(2)) 
        
        return Cube_deconvolved
    
    
    def Physical_resize(self, Cube_deconvolved):
        
        print('Resizing the outflow model to the right physical size')
        
        Sim_size = int(self.npixel-self.npixel/8)-self.npixel/2+1 #Size of the simulated cube  - from the outflow loop
        
        Outflow_r_pixel = self.outflow_r/self.arcsecond_per_pix
        
        
        new_size = self.npixel*Outflow_r_pixel/Sim_size
        new_size=  int(np.round(new_size))
        
        nvel = np.shape(Cube_deconvolved)[0]
        Cube_resize = np.zeros((nvel , new_size, new_size))
    
        for i in tqdm(range(nvel)):
            #Cube_resize[i,:,:]= np.resize(Cube_deconvolved[i,:,:], (new_size, new_size))
            Cube_resize[i,:,:] = imresize(Cube_deconvolved[i,:,:], (new_size, new_size), mode='F')
        
        
        Proper_size_cube = np.zeros((len(self.vels), self.cube_size_pix , self.cube_size_pix))
        diff = np.shape(Proper_size_cube)[2] - new_size
        
        if (diff % 2) == 0:
            half = int(diff/2)
            Proper_size_cube[:, half:(self.cube_size_pix-half), half:(self.cube_size_pix-half)] = Cube_resize
             
        else:
            half = int(diff/2)
            Proper_size_cube[:, half:(self.cube_size_pix-half-1), half:(self.cube_size_pix-half-1)] = Cube_resize
            
         
        return Proper_size_cube
      
    def Convolution(self, Cube_deconvolved):
        'Convolving the cube with the beam. - Right now 2D '
        print('Convolving the cube with the beam')
        
        iters  = range(len(self.vels))
        
        gauss_kernel = Gaussian2DKernel(x_stddev = self.bmaj/self.arcsecond_per_pix, y_stddev = self.bmin/self.arcsecond_per_pix, theta = self.kernel_rotation)

   
        Convolved_cube = np.zeros_like(Cube_deconvolved)
        for i in tqdm(iters):
            Convolved_cube[i,:,:] = convolve(Cube_deconvolved[i,:,:], gauss_kernel )   
        
        return Convolved_cube
    
    def Flux_calibration_ALMA(self, Cube):
        cdelt =self.arcsecond_per_pix/3600
        Norm = 1e3 / (abs((pi*self.bmaj*self.bmin/4.) / (cdelt*cdelt*3600.**2)) / np.log(2.))
        
        use = np.where( (self.vels>-600) & (self.vels<600) )[0]
        
        Flux_sum = Cube[use,:,:].sum()* abs(self.vels[0]-self.vels[1])
        
        Flux_sum = Flux_sum*Norm
        
        rat = Flux_sum/self.flux
        
        return Cube/rat
        
        
    def Nosie_addition(self, Cube, noise_level):
        
        Max_cub = Cube.max()
        std = Max_cub/noise_level
        
        x,y,z = np.shape(Cube)
        noise = np.random.normal(0, std, x*y*z)
        noise = noise.reshape(x,y,z)
        
        
        return Cube+noise
      
    
    def Save_fits(self, Cube):
        'Saving the model cube'        
        today = date.today()
        print ('Saving the fits file')
        hds = pyfits.PrimaryHDU(Cube)
        hds.header['WCSAXES'] = 3
        hds.header['NAXIS'] = 3    

        hds.header['CTYPE1'] =  'RA---SIN'           #/ Right ascension, orthographic/synthesis project                                     #NAXIS   =                    3 / number of data axes
        hds.header['CTYPE2'] =  'DEC--SIN' 
        hds.header['CTYPE3'] =  'VELO-F2V' 
        hds.header['NAXIS3'] = np.shape(Cube)[0]                   #NAXIS3  =                   30 / length of data axis 3
        hds.header['NAXIS1'] = np.shape(Cube)[1]                  #NAXIS1  =                  720 / length of data axis 1
        hds.header['NAXIS2'] = np.shape(Cube)[2]                        #NAXIS2  =                  360 / length of data axis 2
        hds.header['CRVAL1'] = 0                     #CRVAL1  =                   0. / Value of longitude in pixel CRPIX1
        hds.header['CDELT1'] = self.arcsecond_per_pix/3600 #CDELT1  =                  0.5 / Step size in longitude
        hds.header['CRPIX1'] = 1                                        #CRPIX1  =                360.5 / Pixel that has value CRVAL1
        hds.header['CUNIT1'] = 'deg'                                 #CUNIT1  = 'deg     '           / The unit of parameter 1
        hds.header['CRVAL2'] = 0                 #CRVAL2  =                   0. / Value of latitude in pixel CRPIX2
        hds.header['CDELT2'] = self.arcsecond_per_pix/3600 #CDELT2  =                  0.5 / Step size in latitude
        hds.header['CRPIX2'] = 1                                        #CRPIX2  =                180.5 / Pixel that has value CRVAL2
        hds.header['CUNIT2'] = 'deg'                                 #CUNIT2  = 'deg     '           / The unit of parameter 2
        hds.header['CRVAL3'] = self.vels[0]                                             #CRVAL3  =                  50. / Energy of pixel CRPIX3
        hds.header['CDELT3'] = self.vels[1]-self.vels[0]               #CDELT3  =    0.113828620540137 / log10 of step size in energy (if it is logarith
        hds.header['CRPIX3'] = 1                       #CRPIX3  =                   1. / Pixel that has value CRVAL3
        hds.header['CUNIT3'] = 'km/s'                                   #CUNIT3  = 'MeV     '           / The unit of axis 3
        hds.header['DATE'] = today.strftime("%Y-%m-%d")
        
        hds.header['RESTFRQ']  = 3.4e11
        
        hds.writeto(self.mypath+'_cube.fits', overwrite=True)      
    
    def Fast_analyses(self, Model_cube, boundry_up=600., boundry_do=-600.):
        
# =============================================================================
#         Moment maps
# =============================================================================
        cube = SpectralCube.read(self.mypath+'_cube.fits')  
        cube= cube.spectral_slab(boundry_do*u.km/u.s, boundry_up*u.km/u.s)  

        moment_0 = cube.moment(order=0) 
        moment_1 = cube.moment(order=1)  
        moment_2 = cube.moment(order=2)#linewidth_fwhm()
        
        
        moment_0.write(self.mypath+'_m0.fits', overwrite=True)  
        moment_1.write(self.mypath+'_m1.fits', overwrite=True)  
        moment_2.write(self.mypath+'_m2.fits', overwrite=True) 
        
        Header_plt = pyfits.getheader(self.mypath+'_m0.fits')
    
        mnt0m = pyfits.getdata(self.mypath+'_m0.fits')
        m1 = pyfits.getdata(self.mypath+'_m1.fits')
        m2 = pyfits.getdata(self.mypath+'_m2.fits')
        
        f = plt.figure(figsize=(13,4.6 ))

        ax1 = f.add_axes((0.31,0.05,0.2,0.9), projection=wcs.WCS(Header_plt))
        ax2 = f.add_axes((0.55,0.05,0.2,0.9), projection=wcs.WCS(Header_plt))
        ax3 = f.add_axes((0.795,0.05,0.2,0.9), projection=wcs.WCS(Header_plt))
        
        rms = np.nanstd(mnt0m - np.nanmean(mnt0m)) 
        mask_ind = np.where(mnt0m<3*rms)
        

        fl = ax1.imshow(mnt0m, origin='low')
        axcbar0 = f.add_axes([0.31,0.75,0.2,0.05]) #plt.axes([0.055+ 0.2469,0.397,0.189,0.03])
        axcbar0.tick_params(direction='in')        
        cbar0 = f.colorbar(fl, cax=axcbar0 ,orientation='horizontal')
        axcbar0.xaxis.tick_top()
        axcbar0.set_title('Flux (normed)')
        
        
        m1[mask_ind] = np.nan
        fl = ax2.imshow(m1, origin='low',cmap='RdYlBu_r')#, vmin=-200, vmax=200)
        axcbar0 = f.add_axes([ 0.55,0.75,0.2,0.05]) #plt.axes([0.055+ 0.2469,0.397,0.189,0.03])
        axcbar0.tick_params(direction='in')        
        cbar0 = f.colorbar(fl, cax=axcbar0 ,orientation='horizontal')
        axcbar0.xaxis.tick_top()
        axcbar0.set_title(r'Velocity (km s$^{-1}$)')
        
        m2[mask_ind] = np.nan
        fl = ax3.imshow(np.sqrt(m2)*np.sqrt(8*np.log(2)), origin='low')
        
        axcbar0 = f.add_axes([ 0.795,0.75,0.2,0.05]) #plt.axes([0.055+ 0.2469,0.397,0.189,0.03])
        axcbar0.tick_params(direction='in')        
        cbar0 = f.colorbar(fl, cax=axcbar0 ,orientation='horizontal')
        axcbar0.xaxis.tick_top()
        axcbar0.set_title(r'FWHM (km s$^{-1}$)')
        
        ax1.tick_params(direction='in')
        ax2.tick_params(direction='in')
        ax3.tick_params(direction='in')
        
        ax0 = f.add_axes([0.07,0.05,0.2,0.9])
        
        ax0.imshow(self.Flux_rot.sum(axis=(1)),  origin='low', extent=(-self.npixel/2,self.npixel/2,-self.npixel/2,self.npixel/2))
        
        center = [np.shape(m1)[0]/2,  np.shape(m1)[1]/2]
        deg_per_pix = Header_plt['CDELT2']
        arc_per_pix = deg_per_pix*3600
        px = 1./arc_per_pix
        
        cbs = self.cube_size/2
        lims = np.array([-cbs,cbs, -cbs,cbs])#*arc_per_pix
    
        from matplotlib.patches import Ellipse
        c = Ellipse((center[0]-px*0.7, center[1]-px*0.7), self.bmaj/arc_per_pix, self.bmin/arc_per_pix, self.kernel_rotation,  edgecolor='red', facecolor='red', alpha=0.5)   
        ax1.add_patch(c) 
        
    
    
        overide_axes_labels(f, ax1, lims, labelx=1, labely=1)
        overide_axes_labels(f, ax2, lims, labelx=1, labely=0)
        overide_axes_labels(f, ax3, lims, labelx=1, labely=0)
        
# =============================================================================
#         Spectrum
# =============================================================================
        
        mask_in = np.zeros_like(self.Convolved_cube)
        
        mask = np.zeros((self.cube_size_pix,self.cube_size_pix), dtype=int)
        mask[mask_ind] = True
    
        for j in range(len(self.vels)):     
            mask_in[j,:,:] = mask
        
        mask_in = np.array(mask_in, dtype=int)
        
        Cube_inner = np.ma.array(data=self.Convolved_cube_flux, mask=mask_in)
    
        Spectrum = np.ma.sum(Cube_inner, axis=(1,2))
            
        f, ax = plt.subplots(1)
        ax.plot(self.vels, Spectrum, drawstyle='steps-mid')
        ax.tick_params(direction='in')
        
        ax.set_ylabel('Flux')
        ax.set_xlabel('Velocity (km/s)')
        
        plt.tight_layout()
        
    def graph_format(self, Labelsize=12):
        import matplotlib as mpl
        
        print(Labelsize)
        mpl.rcParams['xtick.major.width'] =1.5
        mpl.rcParams['ytick.major.width'] =1.5
        mpl.rcParams['xtick.major.size'] = 5.
        mpl.rcParams['ytick.major.size'] = 5.
        
        mpl.rcParams['xtick.minor.size'] = 3.5
        mpl.rcParams['ytick.minor.size'] = 3.5
        mpl.rcParams['xtick.minor.width'] = 1.5
        mpl.rcParams['ytick.minor.width'] = 1.5
        
    
        mpl.rcParams['xtick.labelsize']= Labelsize
        mpl.rcParams['ytick.labelsize']= Labelsize
       
        mpl.rcParams['axes.linewidth'] = 2.
        
        mpl.rcParams['axes.labelsize']=15
        

